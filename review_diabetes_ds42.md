# Ревью проекта "Сахарный диабет" (DS42)

## Сильные стороны

У проекта хорошо выстроена структура: от загрузки и первичного анализа данных до обучения моделей и итоговых выводов. Подробно описаны признаки с медицинскими пояснениями, что помогает лучше понимать данные. Авторы попробовали два разных подхода к формированию датасетов и сравнили результаты. Для обучения использовались разные модели, от простых до сложных, с подбором гиперпараметров. В процессе учли мультиколлинеарность и возможную утечку данных, а также обработали аномалии. Есть анализ ошибок и важности признаков, при этом результаты интерпретированы в медицинском контексте, что делает проект более прикладным и понятным.

## Недочёты, на которые просим обратить внимание:

В отчёте и коде не совпадают списки удаляемых колонок: в тексте указаны одни индексы, а в коде через np.r_ удаляются другие:


- **Markdown-ячейка:**  
  `Удаляем признаки: 0, 2:6, 10, 11, 15, 17, 21:27, 32, 36:72, 73, 75, 80, 82, 87, 89, 93 ,95, 97, 99, 101`

- **Код (ячейка 36):**
  ```python
  # удаляем признаки, которые не будем использовать в моделировании
  diabetes = diabetes.drop(diabetes.columns[np.r_[0, 21:27, 36:72, 73, 75,
                                                  80, 82, 87, 89, 93, 95,
                                                  97, 99, 101]], axis=1)

---

Список колонок через np.r_ + индексы. Хрупко: при любом изменении порядка — сломается. Лучше именованные списки.

---

В нескольких признаках (гликированный гемоглобин, общий билирубин, мочевина, натрий, калий) вы заменяете пропуски на значение -1. Модель воспринимает его как обычное число, хотя в реальности таких значений быть не может. Это может привести к искажениям и к тому, что алгоритм начнёт учить искусственные правила «если −1 → диабет». Корректнее оставить NaN и обрабатывать пропуски в пайплайне (например, через SimpleImputer(strategy='median')). Или возможно проще удалить строки с пропусками в данных признаках.

---

В отчёте указано использование OrdinalEncoder, а в коде он отсутствует — порядковые признаки остаются как обычные числа. Нужно либо добавить OrdinalEncoder, либо поправить комментарий в markdown-ячейке, чтобы описание соответствовало фактической реализации.

---

Вы используете правило «≤6 уникальных значений = порядковый признак». Если этот порог выбран осознанно после просмотра всех признаков и действительно отражает границу между категориальными и непрерывными данными в вашем наборе, то это допустимо. Но важно уточнить в отчёте, что это решение привязано к данному датасету, а не универсальное правило.

---

После 83 ячейки написано: "Для этого уберем признаки, которые имеют коэффициенты корреляции с другими признаками 0.89, 0.9, 0.92". Непонятно, как выбираются эти признаки, в яном виде они не выведены, а матрица корреляций нечитаема. Еще бросается в глаза слово "мультиколлениарность" вместо мультиколлинеарности.

---

Спорный момент: "Также уберем признаки, имеющие нулевой коэффициент корреляции с целевым признаком". Корреляция показывает линейную зависимость между переменными, но признак может иметь сложную нелинейную связь с таргетом, или может быть полезен в комбинации с другими признаками. В таких моделях, как линейная или логистическая регрессия, корреляция напрямую отражает вклад признака. Если корреляция близка к нулю — признак, скорее всего, не влияет на предсказание, и его можно удалить. Но в нелинейных моделях, например в деревьях решений, где важность определяется иначе, он может быть полезен. Прежде чем удалять признак, следует проверить важность признаков через feature_importances_  или использовать методы отбора, такие как SelectKBest или VarianceThreshold. Либо провести эксперимент: обучить модель с этими признаками и без них и посмотреть — изменилась ли метрика. Если выполняются все три условия: корреляция = 0, и важность в модели = 0, и нет теоретических оснований считать его полезным, то тогда признак следует удалить.

